{
  "hash": "7074d5d22e14006b9e14136a7ba545a6",
  "result": {
    "engine": "knitr",
    "markdown": "# plantecowrap 温度相关拟合 {#sec-plantecowraps}\n\n`plantecophys` 软件包自推出后得到了广泛的关注，2021.11.7 我查了一下谷歌学术记录的引用量为 214 次，但作者对其更新的频率非常缓慢，毕竟离开了科研界。一些新特性的添加估计很难，而 `plantecowrap` 把二氧化碳响应拟合过程中一些重要的参数的温度响应添加了进去，除了那些基础文献外，主要的计算的主要理论依据来自于 [@bernacchi_temperature_2002; @medlyn_temperature_2002]，目的是提供相关参数对温度响应的计算，可以作为对 `plantecophys` 相关功能的补充。\n\n## 无分组数据的使用 {#sec-plantecowrap-nogroup}\n\n软件包介绍参考 @sec-photo-specific，这里使用软件包自带的数据进行演示：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plantecowrap)\ndata <- read.csv(\n  system.file(\"extdata\", \"example_1.csv\",\n              package = \"plantecowrap\"),\n  stringsAsFactors = FALSE\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(data)\n```\n:::\n\n::: {.cell tbl-cap=' '}\n::: {.cell-output-display}\n\n\nTable: plantecowraps 自带的示例数据 #{tbl-plantecowraps}\n\n|  X|        A|  Ci| Tleaf| Press| PPFD| Treat|\n|--:|--------:|---:|-----:|-----:|----:|-----:|\n|  1| 2.154595|  75|    10|   100| 2000|    10|\n|  2| 2.733792| 100|    10|   100| 2000|    10|\n|  3| 3.430289| 150|    10|   100| 2000|    10|\n|  4| 3.834256| 200|    10|   100| 2000|    10|\n|  5| 4.098002| 250|    10|   100| 2000|    10|\n|  6| 4.283738| 300|    10|   100| 2000|    10|\n\n\n:::\n:::\n\n\n\n这里使用的是示例数据。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfits <- fitacis2(\n  data = data,\n  varnames = list(\n    ALEAF = \"A\",\n    Tleaf = \"Tleaf\",\n    Ci = \"Ci\",\n    PPFD = \"PPFD\",\n    Rd = \"Rd\",\n    Press = \"Press\"\n  ),\n  group1 = \"Treat\",\n  fitTPU = FALSE,\n  fitmethod = \"bilinear\",\n  gm25 = 10000,\n  #Allows fitting on an ACi rather than ACc-basis\n  Egm = 0\n)\noutputs <- acisummary(data, group1 = \"Treat\", fits = fits)\n```\n:::\n\n\n到这里为止，如果熟悉 `plantecophys` 的话，一直没有什么新意，只是给 `fitacis` 改了个名字，然后给 25 摄氏度下的叶肉导度赋值了一个不可能的数据，这样是为了使用 Ci 的数据来进行拟合。下面是关键部分了：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntresp <- fit_topt_VJ(outputs)\n```\n:::\n\n\n这里使用这个函数 `fit_topt_VJ` 来拟合 **Vcmax 和 Jmax** 对温度响应的曲线，要查看拟合的参数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntresp[[2]]\n```\n:::\n\n::: {.cell lable='wraps-para' tbl-cap=' '}\n::: {.cell-output-display}\n\n\nTable: plantecowrap 拟合的参数 {#tbl-ecoerap-para}\n\n|Parameter |      k25|       Ea| Residual|      BIC|\n|:---------|--------:|--------:|--------:|--------:|\n|Vcmax     |  75.1461| 53.45129| 73.99293| 53.18597|\n|Jmax      | 148.6158| 78.94620| 60.95280| 52.36863|\n\n\n:::\n:::\n\n\n\n这里是显示拟合参数，k25 是指 25 度时候的 Km，Ea 是活化能。响应图形的查看是：\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntresp[[3]]\n```\n\n::: {.cell-output-display}\n![plantecowrap 的图形查看](plantecowraps_files/figure-html/fig-plantecowrap-plot-1.png){#fig-plantecowrap-plot width=672}\n:::\n:::\n\n能直接看到 $V_{cmax}$ 和 $J_{max}$ 对温度的响应。\n\n\n## 多个分组数据的使用 {#sec-plantecowrap-group}\n\n上面的示例是简单的演示，实际应用中肯定是要有很多分组的，分组代码如下，使用相似，为避免篇幅太长，这里的代码不再实际运行。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# eval: false\ndata2 <- read.csv(\n  system.file(\"extdata\", \"example_2.csv\",\n              package = \"plantecowrap\"),\n  stringsAsFactors = FALSE\n)\n\nhead(data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  X        A  Ci Tleaf Press PPFD Grouping\n1 1 2.154595  75    10   100 2000     10_a\n2 2 2.733792 100    10   100 2000     10_a\n3 3 3.430289 150    10   100 2000     10_a\n4 4 3.834256 200    10   100 2000     10_a\n5 5 4.098002 250    10   100 2000     10_a\n6 6 4.283738 300    10   100 2000     10_a\n```\n\n\n:::\n:::\n\n\n数据根据 Groping 分为了 a,b两组。\n\n```{.r}\nfits2 <- fitacis2(\n  data = data2,\n  varnames = list(\n    ALEAF = \"A\",\n    Tleaf = \"Tleaf\",\n    Ci = \"Ci\",\n    PPFD = \"PPFD\",\n    Rd = \"Rd\",\n    Press = \"Press\"\n  ),\n  group1 = \"Grouping\",\n  fitTPU = FALSE,\n  fitmethod = \"bilinear\",\n  gm25 = 10000,\n  Egm = 0\n)\n\noutputs <- acisummary(data2, group1 = \"Grouping\", fits = fits2)\n\noutputs <-\n  separate(\n    outputs,\n    col = \"ID\",\n    into = c(\"Treat\", \"Block\"),\n    sep = \"_\"\n  )\n\ntresps <- fit_topt_VJs(data = outputs,\n                       group = \"Block\")\n```\n\n\n这里就是利用率分组信息来区分不同的数据组。和上面没太大区别。这里既然使用了多个分组，那么要获取对应的图形和参数，就麻烦一些，但是作者考虑了这一点，直接写好相关的函数，望文生义即可，就是代表字面意思：\n\n```{.r}\npars <- get_t_pars(tresps)\npars\n\ngraphs <- get_t_graphs(tresps)\n\nprint_graphs(graphs, path = \"./exist_dir\")\n```\n\n不过上面这段代码所有的内容实际上已经在 `tresps` 内了，这里仅仅是提取出来方便而已，需要注意，最后图形的导出看上去只是支持临时目录和当前目录，或者是已经存在的目录，即代码里没有做相关目录不存在就先创建目录的处理。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}