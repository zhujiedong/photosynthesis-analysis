{
  "hash": "90de0175311d0f7e9f2d4e4e869183b5",
  "result": {
    "engine": "knitr",
    "markdown": "# 非直角双曲线模型 {#sec-non-hypo}\n\n@Thornley1976 提出了非直角双曲线模型，它的表达式为：\n\n$$\nP_{n} = \\frac{\\alpha I + P_{nmax} \\sqrt{(\\alpha I + P_{nmax})^{2} - 4  \\theta \\alpha I P_{nmax}}}{2 \\theta} - R_{d}\n$$ {#eq-nrec}\n\n其中，$\\theta$ 为表示曲线弯曲程度的曲角参数，取值为$0\\leq \\theta \\leq 1$。其他参数意义同式 @eq-rec。同样如同直角双曲线模型，式仍然没有极值，无法求得 $I_{sat}$，可以仍然参考直角双曲线模型的方式进行计算。\n\n## 非直角双曲线模型的实现 {#sec-nonrec_mode_exam}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(minpack.lm)\n\n# 读取数据，同fitaci数据格式\nlrc <- read.csv(\"data/lrc.csv\")\nlrc <- subset(lrc, Obs > 0)\n\n# 光响应曲线没有太多参数，\n# 直接调出相应的光强和光合速率\n# 方便后面调用\nlrc_Q <- lrc$PARi\nlrc_A <- lrc$Photo \n\n# 非直角双曲线模型的拟合\nlrcnls <- nlsLM(lrc_A ~ \n                (1/(2*theta))*\n                (alpha*lrc_Q+Am-sqrt((alpha*lrc_Q+Am)^2 - \n                4*alpha*theta*Am*lrc_Q))- Rd,\n                start=list(Am=(max(lrc_A)-min(lrc_A)),\n                alpha=0.05,Rd=-min(lrc_A),theta=1)) \n\nfitlrc_nrec <- summary(lrcnls)\n\n# 光补偿点\nIc <- function(Ic){\n  (1/(2 * fitlrc_nrec$coef[4,1])) * \n    (fitlrc_nrec$coef[2,1] * Ic + fitlrc_nrec$coef[1,1] - \n    sqrt((fitlrc_nrec$coef[2,1] * Ic + fitlrc_nrec$coef[1,1]\n    )^2 -  4 * fitlrc_nrec$coef[2,1] * \n    fitlrc_nrec$coef[4,1] * fitlrc_nrec$coef[1,1] * Ic)) -\n    fitlrc_nrec$coef[3,1]\n}\n\nuniroot(Ic, c(0,50))$root  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.234292\n```\n\n\n:::\n\n```{.r .cell-code}\n# 光饱和点\nIsat <- function(Isat){\n  (1/(2 * fitlrc_nrec$coef[4,1])) * (fitlrc_nrec$coef[2,1] * \n  Isat + fitlrc_nrec$coef[1,1] - sqrt(\n  (fitlrc_nrec$coef[2,1] * Isat +fitlrc_nrec$coef[1,1])^2 - \n  4*fitlrc_nrec$coef[2,1] * fitlrc_nrec$coef[4,1] * \n  fitlrc_nrec$coef[1,1] * Isat)) - \n  fitlrc_nrec$coef[3,1] - (0.9*fitlrc_nrec$coef[1,1])}\n\nuniroot(Isat, c(0,2000))$root\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1596.286\n```\n\n\n:::\n\n```{.r .cell-code}\n# 使用ggplot2进行作图并拟合曲线\nlibrary(ggplot2)\nlight <- data.frame(lrc_Q = lrc$PARi, lrc_A = lrc$Photo)\n\nnonrec_form <- y ~ \n  (1/(2*theta))*(alpha*x+Am-sqrt((alpha*x+Am)^2 - \n   4*alpha*theta*Am*x))- Rd\n\nggplot(light, aes(x = lrc_Q, y = lrc_A)) + \n  geom_point(shape = 16, size = 3, color = \"green\") + \n  geom_smooth(method=\"nls\", formula = nonrec_form, se = FALSE,\n  method.args = list(start = c(Am=(max(lrc_A)-min(lrc_A)), \n  alpha=0.05, Rd=-min(lrc_A), theta=1), \n  aes(color='blue', size = 1.2))) +\n  labs(y=expression(paste(\"photosynthetic rate  \", \n          \"(\", mu, mol%.%m^-2%.%s^-1, \")\")), \n       x=expression(paste(\"PAR \", \n           \"(\", mu, mol%.%m^-2%.%s^-1, \")\"))) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![非直角双曲线模型拟合](non-hypo_files/figure-html/fig-nrecr-1.png){#fig-nrecr width=672}\n:::\n:::\n\n::: {#tbl-nrectable .cell tbl-cap='非直角双曲线模型结果'}\n::: {.cell-output-display}\n\n\n|      |   Estimate| Std. Error|    t value| Pr(>&#124;t&#124;)|\n|:-----|----------:|----------:|----------:|------------------:|\n|Am    | 15.8017296|  0.1513064| 104.435285|          0.0000000|\n|alpha |  0.0658067|  0.0020216|  32.551422|          0.0000000|\n|Rd    |  0.1461717|  0.0420800|   3.473659|          0.0070082|\n|theta |  0.3700908|  0.0493403|   7.500783|          0.0000369|\n\n\n:::\n:::\n\n\n最终的数据拟结果如图 @fig-nrecr 所示，拟合的参数及结果见表 @tbl-nrectable。单纯从作图来看，本例数据使用非直角双曲线与散点图重合程度更高。\n\n## 利用函数来拟合 {#sec-fitqa-quick}\n\n上面的方式是手动实现，也并不复杂，`phtosynthesis` 和 `FitAQ` 软件包提供了**非直角双曲线模型**的相应的函数，可以让我们方便的进行处理。\n\n### 使用 `photosynthesis` 处理 {#sec-photosyn-aq}\n\n\n安装可以通过 `CRAN`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('photosynthesis')\n```\n:::\n\n\n我们看一下 LI-6400 数据的使用：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(photosynthesis)\nfit6400 <- fit_aq_response(lrc, varnames = list(A_net = \"Photo\", PPFD = \"PARi\"))\n```\n:::\n\n\n他的拟合结果的查看方式为：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(fit6400[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFormula: A_net ~ aq_response(k_sat, phi_J, Q_abs = data$Q_abs, theta_J) - \n    Rd\n\nParameters:\n                Estimate Std. Error t value Pr(>|t|)    \nk_sat          15.801730   0.151306 104.435 3.43e-15 ***\nphi_J.Q_abs     0.065807   0.002022  32.551 1.20e-10 ***\ntheta_J         0.370091   0.049340   7.501 3.69e-05 ***\nRd.(Intercept)  0.146172   0.042080   3.474  0.00701 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.06845 on 9 degrees of freedom\n\nNumber of iterations to convergence: 6 \nAchieved convergence tolerance: 1.49e-08\n```\n\n\n:::\n:::\n\n\n除此以外，它还提供了只看拟合结果的方式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit6400[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         A_sat      phi_J   theta_J        Rd      LCP  resid_SSs\nk_sat 15.80173 0.06580668 0.3700908 0.1461717 2.234292 0.04216531\n```\n\n\n:::\n:::\n\n他们的意义按顺序为：\n\n1. 饱和光下的净光合速率 (A_sat)，\n\n2. 表观量子效率 (phi_J),\n\n3.  曲线的弯曲程度 (theta_J),\n\n4. 暗呼吸速率 (Rd),\n\n5. 光补偿点 (LCP),\n\n6. 残差的平方和 (resid_SS)。\n\n也可以直接输出图形，只不过要想定制化，还要自己做：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit6400[[3]]\n```\n\n::: {.cell-output-display}\n![photosynthesis 软件包的非直角双曲线拟合图形查看](non-hypo_files/figure-html/photosynthesis-aq-1.png){width=672}\n:::\n:::\n\n\n如果是 LI-6800，稍微修改一下参数即可，这里不再进行一步一步的演示：\n\n\n::: {.cell}\n\n```{.r .cell-code}\naq6800 <- read.csv(\"data/lrc6800.csv\")\nfit6800 <-\n  fit_aq_response(aq6800, varnames = list(A_net = \"A\", PPFD = \"Qin\"))\n```\n:::\n\n\n### 使用 `FitAQ` 处理 {#sec-fiaq}\n\n安装必须是从 github 安装，当然，如果你和我遇到一样登录 github 困难的话，我把他 fork 到 gitee 上去了：\n\n```{.r}\n\nremotes::install_git(\"https://gitee.com/zhu_jie_dong/FitAQ\")\n#或\nremotes::install_github(\"MarkusLoew/FitAQ\")\n```\n\n使用也比较方便，默认这样操作就行了：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(FitAQ)\nFitAQ(data = lrc, A = Photo, Q = PARi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Amax        phi        Rd     theta\nAmax 15.80173 0.06580667 0.1461717 0.3700909\n```\n\n\n:::\n:::\n\n\n如果觉得不满意，还可以手动调整初值，作者考虑的比较周到：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit1 <- FitAQ(\n  data = lrc,\n  A = Photo,\n  Q = PARi,\n  provide.model = TRUE,\n  nlscontrol = c(maxiter = 500),\n  start = list(\n    Amax = 15,\n    phi = 0.06,\n    Rd = 0.14,\n    theta = 0.3\n  ),\n  lower = c(12, 0, 0, 0),\n  upper = c(17, 0.1, 3, 0.5),\n  trace = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  0:     2.6244459:  15.0000 0.0600000 0.140000 0.300000\n  1:   0.021848654:  15.7837 0.0658725 0.146820 0.377608\n  2:   0.021082662:  15.8019 0.0658089 0.146186 0.370045\n  3:   0.021082654:  15.8017 0.0658067 0.146172 0.370090\n  4:   0.021082654:  15.8017 0.0658067 0.146172 0.370091\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFormula: A ~ ((phi * Q + Amax - sqrt((phi * Q + Amax)^2 - 4 * theta * \n    phi * Q * Amax)))/(2 * theta) - Rd\n\nParameters:\n       Estimate Std. Error t value Pr(>|t|)    \nAmax  15.801729   0.151306 104.435 3.43e-15 ***\nphi    0.065807   0.002022  32.551 1.20e-10 ***\nRd     0.146172   0.042080   3.474  0.00701 ** \ntheta  0.370091   0.049340   7.501 3.69e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.06845 on 9 degrees of freedom\n\nAlgorithm \"port\", convergence message: relative convergence (4)\n```\n\n\n:::\n\n```{.r .cell-code}\npredict_range <- data.frame(Q = seq(from = 0, to = 3000, by = 20))\n\naddline <-\n  within(predict_range, A <-\n           predict(fit1, newdata = predict_range))\nplot(\n  Photo ~ PARi,\n  data = lrc,\n  xlim = c(0, 3000),\n  ylim = c(0, 16)\n)\nlines(A ~ Q, data = addline, col = \"blue\", lwd = 3.2)\n```\n\n::: {.cell-output-display}\n![FitAQ 的非直角双曲线拟合](non-hypo_files/figure-html/fitaq-plot-1.png){width=672}\n:::\n:::\n\n这里需要说明，`FitAQ` 作者使用的 base R 的语法，而 `photosynthesis` 则喜欢 `ggplot2`，这两个谈不上优劣，只是相比而言，`photosynthesis` 把一些细节都做了，出结果比较省事，但是要做一些定制化图形的时候没有接口，而 `FitAQ` 则把细节美化留给用户自己来操作，但出基本结果的时候代码量会大一些。定制程度更高一些。\n\n:::{.callout-tip}\n## 提醒\n\n这里做拟合曲线图形的时候用了一个小技巧，与我 @fig-nrecr 所采用的方式完全不同，我的作图实际上是强行把非线性拟合放到 `ggplot2` 内，而这里不需要拟合过程，只需要参数带入模型，得出数据点来，只要数据点足够密集，我们用线连接所有数据点后，看上去就是一条平滑的曲线，这种方式虽然是欺骗，但是并没有错误，数据点足够密集，我们根本看不出是点还是线来。\n:::\n\n饱和点和补偿点的计算也提供了方便的函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFitLCP(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     LCP \n2.234292 \n```\n\n\n:::\n\n```{.r .cell-code}\nFitSat(fit1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     LSP \n1455.489 \n```\n\n\n:::\n\n```{.r .cell-code}\nFitSat(fit1, sat.fac = 0.95, range = c(0, 3200))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     LSP \n2986.574 \n```\n\n\n:::\n:::\n\n\n饱和点也是使用了达到最大饱和光强多少比例时候的值，带入模型求的光强而得到，例如这里修改后使用了 0.95，看上去结果就不不正常了。\n\n至于 LI-6800 的分析，也是一样，修改光合速率和光合有效辐射两个参数的名称即可：\n\n\n::: {.cell}\n\n```{.r .cell-code}\naq6800 <- read.csv(\"data/lrc6800.csv\")\nFitAQ(data = aq6800, A = A, Q = Qin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Amax      phi       Rd     theta\nAmax 39.05857 0.063463 3.243814 0.7451511\n```\n\n\n:::\n:::\n\n\n为了减少篇幅，不在展开做过多的介绍，使用方式和上面演示的 LI-6400 一致。\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}