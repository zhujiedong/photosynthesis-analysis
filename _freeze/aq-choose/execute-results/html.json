{
  "hash": "f606126a1deb6e9415b8157f0005b708",
  "result": {
    "engine": "knitr",
    "markdown": "# 如何选择合适的模型 {#sec-mod-choose}\n\n实际工作中，其实经常遇到有人问选择哪个模型，这个问题简单点的回答就是所有的都试一遍，再看看哪个更合适，但是比较好的做法当然是要通过统计上的验证和根据植物生理来判断，生理上判断比较好解决，拟合参数是不是合适，对于做了一个季节实验的我们来讲，那是相当简单，那统计上的判定呢？那有下面几种方式可供参考。\n\n## AIC 与 BIC {#sec-aic-bic} \n\nAIC 和 BIC 都是用于模型选择的标准^[https://www.rhumbarlv.com/what-does-aic-and-bic-mean/#:~:text=AIC%20means%20Akaike%E2%80%99s%20Information%20Criteria%20and%20BIC%20means,parameters.%20Do%20you%20want%20higher%20or%20lower%20AIC%3F]， 其中他们主要的差别是：\n\n> 其中 AIC 主要应用目的是，对于**给定数据集**的多个模型，判定哪个模型对该数据集最合适，该值越小越合适。\n\n> 而 BIC 的主要目的是对于不同数量拟合参数的模型来选择。同样，该值是越小越好。\n\n但需要注意，如果样本数量过低，那么就需要使用修正的 AIC 指数 [@fabozzi_basics_2014]，即 AICc，这个函数不在 base 中，需要第三方的软件包，例如 `AICcmodavg`。\n\n\n```r\ninstall.packages('AICcmodavg')\n```\n\n为方便，我们使用 `nlsLM` 来进行四种模型的比较：\n \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(minpack.lm)\nlibrary(AICcmodavg)\n\n# 读取数据，同fitaci数据格式\nlrc <- read.csv(\"data/lrc.csv\")\nlrc <- subset(lrc, Obs > 0)\n\n# 光响应曲线没有太多参数，\n# 直接调出相应的光强和光合速率\n# 方便后面调用\nlrc_Q <- lrc$PARi\nlrc_A <- lrc$Photo \n\n# 非直角双曲线模型的拟合\nnon_rec_aq <- nlsLM(lrc_A ~ \n                (1/(2*theta))*\n                (alpha*lrc_Q+Am-sqrt((alpha*lrc_Q+Am)^2 - \n                4*alpha*theta*Am*lrc_Q))- Rd,\n                start=list(Am=(max(lrc_A)-min(lrc_A)),\n                alpha=0.05,Rd=-min(lrc_A),theta=1)) \n# 直角双曲线\nrec_aq <- nlsLM(lrc_A ~ (alpha * lrc_Q * Am) * \n                (1/(alpha * lrc_Q + Am)) - Rd,  \n              start=list(Am=(max(lrc_A)-min(lrc_A)),\n              alpha=0.05,Rd=-min(lrc_A))\n)\n\n# 指数模型的拟合\nexp_aq <- nlsLM(lrc_A ~ Am*(1-exp((-b)*(lrc_Q-Ic))),\n                start=list(Am=(max(lrc_A)-min(lrc_A)),\n                           Ic=5, b=1)\n                )\n\n# 直角双曲线修正模型的拟合\nmod_rec_aq <- nlsLM(lrc_A ~ alpha * ((1 - \n              beta*lrc_Q)/(1 + gamma * lrc_Q)) * lrc_Q - Rd,\n                start=list(alpha = 0.07, beta = 0.00005,\n                           gamma=0.004, Rd = 0.2)\n                )\n\nAIC(rec_aq, non_rec_aq, exp_aq, mod_rec_aq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           df        AIC\nrec_aq      4  -9.142650\nnon_rec_aq  5 -27.611987\nexp_aq      4   7.099285\nmod_rec_aq  5 -19.268459\n```\n\n\n:::\n\n```{.r .cell-code}\nBIC(rec_aq, non_rec_aq, exp_aq, mod_rec_aq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           df        BIC\nrec_aq      4  -6.882852\nnon_rec_aq  5 -24.787240\nexp_aq      4   9.359083\nmod_rec_aq  5 -16.443712\n```\n\n\n:::\n:::\n\n对于 `AICc` 使用则略微麻烦，因为它没有直接支持向量化操作：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(list(rec_aq, non_rec_aq, exp_aq, mod_rec_aq), AICc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] -4.14265\n\n[[2]]\n[1] -19.04056\n\n[[3]]\n[1] 12.09929\n\n[[4]]\n[1] -10.69703\n```\n\n\n:::\n:::\n\n\n我们可以看到，结果里出现了负数，这是合理的，我们所讲的越小越好，没有说必须是正直，负值是合理的，而且是常见的。\n\n## 方差分析 {#sec-f-test}\n\n这个经典方法常常因为就在眼前而让人忽视，实际上他也是可以的，看看 R 是怎么描述 `anova` 的：\n\n> Compute analysis of variance (or deviance) tables for one or more fitted model objects.\n\n当然了，过程很简单:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(rec_aq, non_rec_aq, exp_aq, mod_rec_aq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Variance Table\n\nModel 1: lrc_A ~ (alpha * lrc_Q * Am) * (1/(alpha * lrc_Q + Am)) - Rd\nModel 2: lrc_A ~ (1/(2 * theta)) * (alpha * lrc_Q + Am - sqrt((alpha * lrc_Q + Am)^2 - 4 * alpha * theta * Am * lrc_Q)) - Rd\nModel 3: lrc_A ~ Am * (1 - exp((-b) * (lrc_Q - Ic)))\nModel 4: lrc_A ~ alpha * ((1 - beta * lrc_Q)/(1 + gamma * lrc_Q)) * lrc_Q - Rd\n  Res.Df Res.Sum Sq Df   Sum Sq F value    Pr(>F)    \n1     10    0.20360                                  \n2      9    0.04217  1  0.16144  34.458 0.0002377 ***\n3     10    0.71020 -1 -0.66803 142.588 8.030e-07 ***\n4      9    0.08011  1  0.63009  70.787 1.477e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n不管是从残差的平方和还是 p 值上看，都与 AIC 和 BIC 结果一致。\n\n\n## 肉眼判断 {#sec-aq-eye}\n\n\n标题有点搞笑，但其实是可以快速筛选判断的，只不过文章里面或附录里面才需要上面的方法来提供数据支持。例如我们把前面几个方程作图的代码整合在一起看一下数据的情况：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\n# 直角双曲线\nrectangular <- y ~ (alpha * x * Am) * (1/(alpha * x + Am)) - Rd\n# 非直角双曲线\nnon_rectangular <- y ~ \n  (1/(2*theta))*(alpha*x+Am-sqrt((alpha*x+Am)^2 - \n   4*alpha*theta*Am*x))- Rd\n\n# 指数模型\nexponential <- y ~ Am*(1-exp((-b)*(x -Ic)))\n\n# 修改模型\n\nrectangular_revised <-  y ~ \n  alpha * ((1 - beta*x)/(1 + gamma * x)) * x - Rd\n\nggplot(lrc, aes(x = lrc_Q, y = lrc_A)) + \n  geom_point(shape = 16, size = 3, color = \"gray\")+\n  \n  geom_smooth(method=\"nls\", formula = rectangular, \n              se = FALSE, color='black',\n  method.args = list(start = c(\n  Am = (max(lrc_A) - min(lrc_A)),\n  alpha = 0.05,\n  Rd = -min(lrc_A)),\n  aes(x =lrc_Q, y = lrc_A, \n   size = 0.9))\n  )  +\n  \n  geom_smooth(method=\"nls\", formula = non_rectangular, \n              se = FALSE, color='red', \n  method.args = list(start = c(Am=(max(lrc_A)-min(lrc_A)), \n  alpha=0.05, Rd=-min(lrc_A), theta=1), \n  aes(x =lrc_Q, y = lrc_A, size = 1.2))) +\n                \n  geom_smooth(method=\"nls\", formula = exponential, \n    se = FALSE,  color='green',\n    method.args = list(\n    start = c(Am=(max(lrc_A)-min(lrc_A)),\n    Ic=5, b=0.002), aes(x =lrc_Q, y = lrc_A, \n    size = 0.9))\n  )+\n      \n  geom_smooth(method=\"nls\", \n    formula = rectangular_revised,  color='blue',\n    se = FALSE, method.args = list(\n    start = c(alpha = 0.07, beta = 0.00005,\n              gamma=0.004, Rd = 0.2), \n    aes(x =lrc_Q, y = lrc_A, \n    size = 0.9))\n  ) + \n  labs(y=expression(paste(\"photosynthetic rate  \", \n          \"(\", mu, mol%.%m^-2%.%s^-1, \")\")), \n       x=expression(paste(\"PAR \", \n           \"(\", mu, mol%.%m^-2%.%s^-1, \")\")))+\n  theme_light()\n```\n\n::: {.cell-output-display}\n![可以明显淘汰一种模型的例子](aq-choose_files/figure-html/fig-cominbe-aq-1.png){#fig-cominbe-aq width=672}\n:::\n:::\n\n\n该例子并不是特别典型，但结果上来看，红线和蓝线，也就是非直角双曲线和直角双曲线修改模型，看上去比较符合变化趋势。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}