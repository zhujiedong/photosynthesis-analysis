{
  "hash": "f5ea7b8c6128a2403d49df8775fcb955",
  "result": {
    "engine": "knitr",
    "markdown": "# Rd 呼吸   相关 {#sec-rd-related}\n\n本节标题的翻译足够让我头大，@Farquhar1980A 对 R~d~ 的解释为：\n\n>  The symbol R~d~ represents CO~2~ evolution from mitochondria in the light, other  than that associated with the PCO cycle. Mitochondrial oxygen uptake and electron transport associated with normal dark respiration are likely to be inhibited by illumination but CO~2~ release may continue. For want of a better term we call this  **\"dark respiration\"**.\n\n然而我不喜欢这个叫法，感觉容易误解。本文的主要目的是使用 `photosynthesis` 来计算有光条件下呼吸，软件包对这个过程的叫法叫做 light respiration，具体说是两个参数，具体的翻译我采用了 @yinC3C4Photosynthesis2009 的表述：\n\n1. $R_d$：通常称之为明呼吸速率，是指无光呼吸的 $CO_2$ 释放。\n2. $\\Gamma^*$：在无光呼吸的情况下的基于 $C_c$ 的 $CO_2$ 补偿点。\n\n我作为非专业人士，若觉得我写错了或者难以难以理解，请参考文献原文。\n\n## Laisk 方法概述 {#sec-laisk-method}\n\n\nLaisk 方法参考的文献为 @brooksEffectTemperatureCO21985，基本实验方法和原则是：\n\n在不同的低光条件下测量 $CO_2$ 响应曲线（例如该文采用了四个低光条件），这样寻找这几个响应曲线的交点，也就是四条曲线 A 值相同的点，然后采用该 A 值下的 $C_i$ 值作为对 $\\Gamma^*$ 的估计，而 A 值则作为对 $-R_d$ 的估计。\n\n采用的 $C_i$ 范围较小，此范围内响应曲线是近线性的，每个光强下的响应曲线采用的是线性拟合。他们的交点是通过计算获得，从而计算上面的  $\\Gamma^*$ 和  $-R_d$。\n\n当然这篇文献里还提到的 $R_n$，这是和 $R_d$ 相对的概念，是我们通常称为暗呼吸速率的参数。测量方式是当光源关闭后，呼吸速率快速下降，然后在 30-45 min 的黑暗处理后，该速率基本停止后作为暗呼吸速率。\n\n@walkerImprovedMethodMeasuring2015a 给出了上述方式的示意图：\n\n\n\n![Laisk 方法示例](img/laisk.png){#fig-laisk-exam}\n\n\n上面的图形使用的是三项式拟合的结果。\n\n### 基本计算方法 {#sec-laisk-cal-method}\n\n@walkerImprovedMethodMeasuring2015a 对于交点的判定给出了详细论述，如上图所示，这几条曲线（或最初的线性）并不是总会完全相交于一点。通常采用的方法是将所有曲线（或直线）的交点进行取均值。实践中，这些点很少收敛于单点，**通常移除某交点或重新测量直到交点的标准差在某范围内**。但总之会存在一定缺陷，因而 @walkerImprovedMethodMeasuring2015a 对上述方法做了一个改变：\n\n$$\nC_i^* = \\frac{b1-b2}{m_2 -m_1}\n$${#eq-laisk-walker1}\n\n其中 $C_i^*$ 的意义为上文提到的计算的 $\\Gamma^*$, m 表示两条响应曲线线性部分的直线的斜率，b 表示截距。之后再进行计算：\n\n$$\nR_d = m C_i^* + b\n$${#eq-laisk-walker2}\n\n该方法的基本步骤是：\n\n1. 将每条曲线的 m 值作为 x 轴，b 值作为 y 轴，那么对其做一个标准的线性回归，这条回归线的斜率为：\n\n\n$$\nm_{reg} = \\frac{b_2-b_1}{m_2 -m_1}\n$${#eq-laisk-walker3}\n\n将其乘以 -1，并整理方程，那么我们可以得到下面的公式：\n\n$$\nb=-C_i^* + b_{reg}\n$${#eq-laisk-walker4}\n\n那么：\n\n$$\nR_d = b_{reg}\n$${#eq-laisk-walker5}\n\n## Kok 方法 {#sec-kok-method}\n\n由于 @kokInhibitionPhotosynthesisIntense1956 的方法是基于氧气的测量，尽管原则一样，但我不想浪费精力学习现在基本抛弃的测量方式，所以下面的描述基于 @wayResponsesRespirationLight2019：\n\nKok 方法基于在弱光 ( $\\lt 100 \\mu mol \\cdot m^{-2} \\cdot m^{-1}$ ) 下测量净光合速率。当光强从低到高渐变时，净光合速率增加，但这个增加的斜率通常存在一个中断。计算 $R_d$ 通常是基于该中断代表了从 $R_n$ 到光下对 $R_n$ 的已知阶段。因此 $R_d$ 可以通过拟合高于该断点的数据点并进行差值后与 y 轴的交点来表示。如下图作者测量了不同温度下的 $R_d$:\n\n\n![Kok 方法示例](img/kok-temp.png){#fig-kok-method-fig}\n\n\n当然该方法存在争论，但是他的测量比较简单，争论内容不在本文讨论之列。\n\n## Yin 方法 {#sec-yin-method}\n\n@yinEvaluatingNewMethod2011 使用 LI-6400 进行光合荧光同步测量来进行，光强的设置为：\n\n$$5,10,15,20,30,50,70,100,150,200$$\n设置 C~a~ 的浓度为 $370 \\mu mol \\cdot mol$，但外界的 $O_2$ 浓度为 2%。并且为验证光强设置的方向是否影响 $R_d$，单独进行了正向和反向的光强实验。荧光测量遵循了 LI-6400 的测量原则。\n\n\n![Yin 方法测量 Rd 示例](img/yin-rd.png){#fig-yin}\n\n\n$R_d$ 的计算使用了上图的方法，与 Kok 类似，不过横坐标的数值为 $\\Phi PSII/4$。该方法只适用于改进的 $R_d$ 的计算。\n\n## 函数简介 {#sec-rd-func-intr}\n\n实际上有三个函数，但他们有共同的参数，道理很简单，他们基于的理论大部分相同：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_r_light_kok(\n  data,\n  varnames = list(A_net = \"A_net\", PPFD = \"PPFD\"),\n  PPFD_lower = 40,\n  PPFD_upper = 100\n)\n\nfit_r_light_WalkerOrt(\n  data,\n  varnames = list(A_net = \"A_net\", C_i = \"C_i\", PPFD = \"PPFD\"),\n  P = 100,\n  C_i_threshold = 300\n)\n\nfit_r_light_yin(\n  data,\n  varnames = list(A_net = \"A_net\", PPFD = \"PPFD\", phi_PSII = \"phi_PSII\"),\n  PPFD_lower = 40,\n  PPFD_upper = 100\n)\n```\n:::\n\n\n主要的参数，我们通过上面的介绍部分都能看明白，分别是适用于 LI-6400 或 LI-6800 的 `varnames`，以及最小光强或者最大光强，外界气压 `P`，以及部分方法中 $C_i$ 的临界点 `C_i_threshold`。\n\n## 实践 {#sec-in-action}\n\n实践还是采用叶肉导度测试的数据，来自于软件包自带。代码来自于 `vignette`，主要对其中内容做相关解释。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(photosynthesis)\ndata <- read.csv('data/A_Ci_Q_data_1.csv')\n```\n:::\n\n\n加载软件包并读取示例数据。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_light <- fit_r_light_yin(\n  data = data,\n  varnames = list(\n    A_net = \"A\",\n    PPFD = \"Qin\",\n    phi_PSII = \"PhiPS2\"\n  ),\n  PPFD_lower = 20,\n  PPFD_upper = 250\n)\n```\n:::\n\n\n$R_d$ 为截距：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_light\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n -0.7721399 \n```\n\n\n:::\n:::\n\n\n当然，Kok 方法与之类似：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_light <- fit_r_light_kok(\n  data = data,\n  varnames = list(\n    A_net = \"A\",\n    PPFD = \"Qin\",\n    phi_PSII = \"PhiPS2\"\n  ),\n  PPFD_lower = 20,\n  PPFD_upper = 250\n)\nr_light\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n -0.5237011 \n```\n\n\n:::\n:::\n\n\n结果为负值当然表示这是呼吸的意思。\n\n示例程序还演示了不同分组的数据批量的处理，这里的分组是使用了 sample 气路的二氧化碳浓度，首先将其取整，然后转化为 `factor` 后处理，也就是前两行代码所做的处理。之后使用 `Yin` 的方法将所有分组的数据同时处理；\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$C_s <- (round(data$CO2_s, digits = 0))\ndata$C_s <- as.factor(round(data$C_s, digits = -1))\n\n\nr_lights <- fit_many(\n  data = data,\n  funct = fit_r_light_yin,\n  group = \"C_s\",\n  varnames = list(\n    A_net = \"A\",\n    PPFD = \"Qin\",\n    phi_PSII = \"PhiPS2\"\n  ),\n  PPFD_lower = 20,\n  PPFD_upper = 250\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |========                                                              |  11%\n  |                                                                            \n  |================                                                      |  22%\n  |                                                                            \n  |=======================                                               |  33%\n  |                                                                            \n  |===============================                                       |  44%\n  |                                                                            \n  |=======================================                               |  56%\n  |                                                                            \n  |===============================================                       |  67%\n  |                                                                            \n  |======================================================                |  78%\n  |                                                                            \n  |==============================================================        |  89%\n  |                                                                            \n  |======================================================================| 100%\n```\n\n\n:::\n:::\n\n然后将数据整理一下：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup <- names(r_lights)\nr_lights <- do.call(\"c\", r_lights)\nr_light_yin <- data.frame(x = group, y = r_lights, stringsAsFactors = FALSE)\nr_light_yin$x <- as.numeric(r_light_yin$x)\ncolnames(r_light_yin) <- c(\"C_s\", \"r_light\")\n```\n:::\n\n\n首先提取不同的分组，这里是浓度的数据，然后将其转化为一个向量。最终将数据整理为一个数据框，第一列是分组名，第二列是对应的截距，或者说是 $R_d$。最后将数据框的表头修改为所需要的表头，结果为：\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: Yin 的方法测量的结果 {#tbl-yin-kable}\n\n|                 |  C_s|    r_light|\n|:----------------|----:|----------:|\n|50.(Intercept)   |   50| -0.4795729|\n|100.(Intercept)  |  100| -0.5840415|\n|200.(Intercept)  |  200| -0.6015973|\n|300.(Intercept)  |  300| -0.7388560|\n|410.(Intercept)  |  410| -0.7800892|\n|600.(Intercept)  |  600| -0.6269801|\n|820.(Intercept)  |  820| -0.7022602|\n|1200.(Intercept) | 1200| -0.5198403|\n|1600.(Intercept) | 1600| -0.3685110|\n\n\n:::\n:::\n\n\nwalker 方法相比来说要复杂一些，因为多求了一个参数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwalker_ort <-\n  fit_r_light_WalkerOrt(data, varnames = list(A_net = \"A\", C_i = \"Ci\", PPFD = \"Qin\"))\n\nsummary(walker_ort[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Intercept ~ Slope, data = coefs)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.36114 -0.10958 -0.05553  0.08166  0.62016 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -0.1526     0.1176  -1.297    0.224    \nSlope        -4.6004     0.4069 -11.307  5.1e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2513 on 10 degrees of freedom\nMultiple R-squared:  0.9275,\tAdjusted R-squared:  0.9202 \nF-statistic: 127.8 on 1 and 10 DF,  p-value: 5.103e-07\n```\n\n\n:::\n:::\n\n\n通过图形才能很好的反应他使用单条线的斜率和截距来计算的情况：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwalker_ort[[2]]\n```\n\n::: {.cell-output-display}\n![图形方式查看 Walker 的测量方法](Rd_files/figure-html/fig-yin-plot-1.png){#fig-yin-plot width=672}\n:::\n:::\n\n\n数据的结果：\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\nTable: Walker 的方法测量的结果 {#tbl-walker-kable}\n\n|      | GammaStar|   r_light|\n|:-----|---------:|---------:|\n|Slope |  46.00427| -0.152643|\n\n\n:::\n:::\n\n\n就是这些内容了，属于比较使用的函数。\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}